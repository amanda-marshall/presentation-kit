# Settins
int hearBeatWindow = 4;
int boxSize = 128;
int boxStrokeWidth = 8;
int distractorCount = 16;
int distractorSize = 64;
double distractorAnimationDuration = 500.0;
double distractorAniationAsyncDelay = 200.0; # Together with the duration, this should not exceed the anticipated heartbeat interval (e.g. 1200ms)
int displayWidth = display_device.width();
int displayHeight = display_device.height();

# Utility function to draw the target box in the middle
sub
  addBox(
    picture& p,
    bool isFilled,
    bool isShowingCross,
    bool isShowingCheckmark
  )
begin

  # Internal Settings
  rgb_color colorForeground = fontColor;
  rgb_color colorBackground = colorBackgroundLight;

  # Draw box background (to avoid distractors behind the box)
  p.add_part(new box(boxSize + boxStrokeWidth * 2.0, boxSize + boxStrokeWidth * 2.0, colorBackground), 0, 0);

  # Draw the box, filled or not filled
  if isFilled then
    # For a filled box, only one box is needed
    p.add_part(new box(boxSize, boxSize, colorForeground), 0, 0);
  else
    # Draw individual strokes: top, bottom, left, right
    p.add_part(new box(boxStrokeWidth, boxSize, colorForeground), 0, boxSize * 0.5 - boxStrokeWidth * 0.5); # Top line
    p.add_part(new box(boxStrokeWidth, boxSize, colorForeground), 0, boxSize * (-0.5) + boxStrokeWidth * 0.5); # Bottom line
    p.add_part(new box(boxSize, boxStrokeWidth, colorForeground), boxSize * (-0.5) + boxStrokeWidth * 0.5, 0); # Left Line
    p.add_part(new box(boxSize, boxStrokeWidth, colorForeground), boxSize * 0.5 - boxStrokeWidth * 0.5, 0); # Right Line
  end;

  if isShowingCross || isShowingCheckmark then

    # Set up line graphic
    line_graphic lg = new line_graphic();
    lg.set_line_width(boxStrokeWidth);
    lg.set_join_type(join_point);

    # Pick line color based on filled/unfilled box background
    if isFilled then
      lg.set_line_color(colorBackground);
    else
      lg.set_line_color(colorForeground);
    end;

    # Set Scaling
    double scalingFactor = boxSize / 128.0;

    # Define points to be drawn either for a cross or checkmark
    if isShowingCross then
      array<double> points[][] = {{40.0,40.0}, {64.0, 64.0}, {88.0, 40.0}, {64.0, 64.0}, {88.0, 88.0}, {64.0, 64.0}, {40.0, 88.0}};
      drawPolyLineScaled(lg, points, scalingFactor, false);
    else
      array<double> points[][] = {{40.0, 64.0}, {56.0, 80.0}, {88.0, 40.0}};
      drawPolyLineScaled(lg, points, scalingFactor, false);
    end;

    # Draw
    lg.redraw();
    p.add_part(lg, -64 * scalingFactor, 64 * scalingFactor);

  end;

end;


# Utility function to draw the distractors
sub
  addDistractors(
    picture& p,
    array<double,1>& xO,
    array<double,1>& yO,
    array<double,1>& xT,
    array<double,1>& yT,
    double progress
  )
begin

  # Internal Settings
  rgb_color colorForeground = fontColor;
  rgb_color colorBackground = colorBackgroundLight;

  loop
    int i = 1;
  until i > distractorCount begin
    ellipse_graphic e = new ellipse_graphic();
    e.set_dimensions(double(distractorSize), double(distractorSize));
    e.set_color(colorForeground);
    e.redraw();
    p.add_part(
      e,
      lerp(xO[i], xT[i], progress),
      lerp(yO[i], yT[i], progress)
    );
    i = i + 1;
  end;

end;


# Creates new target coordinates for distractors
sub
  newCoordinates(
    array<double,1>& x,
    array<double,1>& y
  )
begin
  int count = x.count();
  loop
    int i = 1;
  until i > count begin
    x.fill(i, i, displayWidth * (-0.5) + double(random(distractorSize * (-2), displayWidth + distractorSize * 2)), 0.0);
    y.fill(i, i, displayHeight * (-0.5) + double(random(distractorSize * (-2), displayHeight + distractorSize * 2)), 0.0);
    i = i + 1;
  end;
end;


# Makes a trial of a given duration with a fixation cross and sends a trigger
sub
  showDistractorTrial(bool isFilled)
begin

  # Internal
  array<double> xOrigin[distractorCount];
  array<double> yOrigin[distractorCount];
  array<double> xTarget[distractorCount];
  array<double> yTarget[distractorCount];

  # Set up initial coordinates
  newCoordinates(xOrigin, yOrigin);
  newCoordinates(xTarget, yTarget);

  int judgementHeartBeat = random(hearBeatWindow-1, hearBeatWindow+1);
  int judgementDelay = random(0, 600);

  # Set up trial
  trial t = new trial;
  t.set_type(fixed);
  t.set_duration(17); # Try for 60FPS

  # Check if input port was set up
	bool has_ports = input_port_manager.port_count() > 0;
	if !has_ports then exit("No input port for heart rate triggers defined"); end;
	input_port port = input_port_manager.get_port(1);
	port.clear();

  loop
    int pulseCount = 1;
    bool canBeJudged = false;
    int timeStart = clock.time();
  until pulseCount > (hearBeatWindow + 2) begin

    # Remove last frame
    if t.stimulus_event_count() > 0 then
      t.remove_stimulus_event(1);
    end;

    # Calculate movement progress
    int timeNow = clock.time();
    double progress;
    if pulseCount <= 1 then
      # Wait one heartbeat to ensure there is a small interval between the trial starting and the first movement
      progress = 0.0;
    else
      progress = easeOutQuad(clamp(0.0, 1.0, ((timeNow - timeStart) / distractorAnimationDuration)));
    end;

    # Determine how soon the user can make a judgement
    if !canBeJudged && pulseCount == judgementHeartBeat && (timeNow - timeStart) >= judgementDelay then
      canBeJudged = true;
    end;

    # Create new frame
    picture p = new picture();
    addDistractors(p, xOrigin, yOrigin, xTarget, yTarget, progress);
    addBox(p, canBeJudged, false, false);
    t.add_stimulus_event(p);

    # Go through new port codes for heart beat detection
    loop int i = 1; until i > port.total_count()
		begin
      if port.codes(i) == 255 then

        pulseCount = pulseCount + 1;

        # Make new coordinates (not for last interval)
        if pulseCount <= (hearBeatWindow + 1) then
          timeStart = clock.time();
          xOrigin = xTarget;
          yOrigin = yTarget;
          newCoordinates(xTarget, yTarget);
        end;

        break;

		  end;
			i = i + 1;
		end;

    port.clear();
    t.present();

  end;

end;
